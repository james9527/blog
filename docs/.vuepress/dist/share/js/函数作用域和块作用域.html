<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数作用域和块级作用域 | james9527的前端日志</title>
    <meta name="description" content="欢迎访问我的前端日志~">
    <link rel="icon" href="https://github.githubassets.com/favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
    
    <link rel="preload" href="/assets/css/0.styles.50972fb1.css" as="style"><link rel="preload" href="/assets/js/app.c069b616.js" as="script"><link rel="preload" href="/assets/js/2.9f793532.js" as="script"><link rel="preload" href="/assets/js/20.0d118671.js" as="script"><link rel="prefetch" href="/assets/js/10.89c3f046.js"><link rel="prefetch" href="/assets/js/11.016745ab.js"><link rel="prefetch" href="/assets/js/12.cb68ab2f.js"><link rel="prefetch" href="/assets/js/13.deaed419.js"><link rel="prefetch" href="/assets/js/14.fda22e8b.js"><link rel="prefetch" href="/assets/js/15.673f0c8e.js"><link rel="prefetch" href="/assets/js/16.d818c6fe.js"><link rel="prefetch" href="/assets/js/17.e4a3e6af.js"><link rel="prefetch" href="/assets/js/18.dfb8cfdb.js"><link rel="prefetch" href="/assets/js/19.93c74c05.js"><link rel="prefetch" href="/assets/js/21.ce2dcf1c.js"><link rel="prefetch" href="/assets/js/22.791b41ee.js"><link rel="prefetch" href="/assets/js/23.c3376b87.js"><link rel="prefetch" href="/assets/js/24.8f098211.js"><link rel="prefetch" href="/assets/js/25.91c739a5.js"><link rel="prefetch" href="/assets/js/26.b33cdc83.js"><link rel="prefetch" href="/assets/js/27.96bfc87d.js"><link rel="prefetch" href="/assets/js/28.1d709250.js"><link rel="prefetch" href="/assets/js/29.e67a9bc1.js"><link rel="prefetch" href="/assets/js/3.c060a925.js"><link rel="prefetch" href="/assets/js/30.9f012d81.js"><link rel="prefetch" href="/assets/js/4.7bbfc35f.js"><link rel="prefetch" href="/assets/js/5.0e4b6e30.js"><link rel="prefetch" href="/assets/js/6.fe752fd6.js"><link rel="prefetch" href="/assets/js/7.36d98635.js"><link rel="prefetch" href="/assets/js/8.c7e7690c.js"><link rel="prefetch" href="/assets/js/9.6acd8702.js">
    <link rel="stylesheet" href="/assets/css/0.styles.50972fb1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">james9527的前端日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="随手记系列" class="dropdown-title"><span class="title">随手记系列</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/share/eslint.html" class="nav-link">eslint规则</a></li><li class="dropdown-item"><!----> <a href="/share/opt.html" class="nav-link">性能优化</a></li><li class="dropdown-item"><!----> <a href="/share/webpack.html" class="nav-link">深入webpack</a></li><li class="dropdown-item"><!----> <a href="/share/webpack-note.html" class="nav-link">webpack随手记</a></li><li class="dropdown-item"><!----> <a href="/share/wechat.html" class="nav-link">公众号开发总结</a></li><li class="dropdown-item"><!----> <a href="/share/scaffold.html" class="nav-link">深入浅出前端脚手架</a></li><li class="dropdown-item"><!----> <a href="/share/javascript-basic.html" class="nav-link">前端基础JS系列</a></li><li class="dropdown-item"><!----> <a href="/share/optimize.html" class="nav-link">移动端性能优化(一)</a></li><li class="dropdown-item"><!----> <a href="/share/optimize2.html" class="nav-link">移动端性能优化(二)</a></li><li class="dropdown-item"><!----> <a href="/share/md.html" class="nav-link">markdown语法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工作相关" class="dropdown-title"><span class="title">工作相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/skulpt/1.html" class="nav-link">深入skulpt</a></li><li class="dropdown-item"><!----> <a href="/scratch/links.html" class="nav-link">深入scratch</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机英语" class="dropdown-title"><span class="title">计算机英语</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/en/webpack.html" class="nav-link">webpack 英文</a></li><li class="dropdown-item"><!----> <a href="/en/npm.html" class="nav-link">npm 英文</a></li><li class="dropdown-item"><!----> <a href="/en/skulpt.html" class="nav-link">skulpt 英文</a></li><li class="dropdown-item"><!----> <a href="/en/scratch.html" class="nav-link">scratch 英文</a></li><li class="dropdown-item"><!----> <a href="/en/ecma.html" class="nav-link">ecma 英文</a></li></ul></div></div><div class="nav-item"><a href="/url/fe.html" class="nav-link">常用网址</a></div><div class="nav-item"><a href="https://github.com/james9527" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="随手记系列" class="dropdown-title"><span class="title">随手记系列</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/share/eslint.html" class="nav-link">eslint规则</a></li><li class="dropdown-item"><!----> <a href="/share/opt.html" class="nav-link">性能优化</a></li><li class="dropdown-item"><!----> <a href="/share/webpack.html" class="nav-link">深入webpack</a></li><li class="dropdown-item"><!----> <a href="/share/webpack-note.html" class="nav-link">webpack随手记</a></li><li class="dropdown-item"><!----> <a href="/share/wechat.html" class="nav-link">公众号开发总结</a></li><li class="dropdown-item"><!----> <a href="/share/scaffold.html" class="nav-link">深入浅出前端脚手架</a></li><li class="dropdown-item"><!----> <a href="/share/javascript-basic.html" class="nav-link">前端基础JS系列</a></li><li class="dropdown-item"><!----> <a href="/share/optimize.html" class="nav-link">移动端性能优化(一)</a></li><li class="dropdown-item"><!----> <a href="/share/optimize2.html" class="nav-link">移动端性能优化(二)</a></li><li class="dropdown-item"><!----> <a href="/share/md.html" class="nav-link">markdown语法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工作相关" class="dropdown-title"><span class="title">工作相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/skulpt/1.html" class="nav-link">深入skulpt</a></li><li class="dropdown-item"><!----> <a href="/scratch/links.html" class="nav-link">深入scratch</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机英语" class="dropdown-title"><span class="title">计算机英语</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/en/webpack.html" class="nav-link">webpack 英文</a></li><li class="dropdown-item"><!----> <a href="/en/npm.html" class="nav-link">npm 英文</a></li><li class="dropdown-item"><!----> <a href="/en/skulpt.html" class="nav-link">skulpt 英文</a></li><li class="dropdown-item"><!----> <a href="/en/scratch.html" class="nav-link">scratch 英文</a></li><li class="dropdown-item"><!----> <a href="/en/ecma.html" class="nav-link">ecma 英文</a></li></ul></div></div><div class="nav-item"><a href="/url/fe.html" class="nav-link">常用网址</a></div><div class="nav-item"><a href="https://github.com/james9527" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>函数作用域和块级作用域</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_1-1-函数作用域" class="sidebar-link">1.1  函数作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_1-1-1-匿名和具名" class="sidebar-link">1.1.1  匿名和具名</a></li><li class="sidebar-sub-header"><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_1-1-2-立即执行函数表达式（iife）" class="sidebar-link">1.1.2 立即执行函数表达式（IIFE）</a></li></ul></li><li><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_2-1-块作用域" class="sidebar-link">2.1  块作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_2-1-1-with" class="sidebar-link">2.1.1  with</a></li><li class="sidebar-sub-header"><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_2-1-2-try-catch" class="sidebar-link">2.1.2  try/catch</a></li><li class="sidebar-sub-header"><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_2-1-3-let" class="sidebar-link">2.1.3  let</a></li><li class="sidebar-sub-header"><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_2-1-4-const" class="sidebar-link">2.1.4  const</a></li><li class="sidebar-sub-header"><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_2-1-5-块作用域的替代方案" class="sidebar-link">2.1.5  块作用域的替代方案</a></li></ul></li><li><a href="/share/js/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F.html#_3-1-小结" class="sidebar-link">3.1  小结</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="函数作用域和块级作用域"><a href="#函数作用域和块级作用域" class="header-anchor">#</a> 函数作用域和块级作用域</h1> <h2 id="_1-1-函数作用域"><a href="#_1-1-函数作用域" class="header-anchor">#</a> 1.1  函数作用域</h2> <p>我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。</p> <blockquote><p>区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。（诀窍：左声明右表达式）</p></blockquote> <h3 id="_1-1-1-匿名和具名"><a href="#_1-1-1-匿名和具名" class="header-anchor">#</a> 1.1.1  匿名和具名</h3> <p>对于函数表达式你最熟悉的场景可能就是回调参数了，比如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;I waited 1 second!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>匿名函数表达式书写起来简单快捷，但是也有缺点：</p> <ul><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难；</li> <li>如果没有函数名，当函数需要引用自身时只能使用已经过期的<code>arguments.callee</code>引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li></ul> <h3 id="_1-1-2-立即执行函数表达式（iife）"><a href="#_1-1-2-立即执行函数表达式（iife）" class="header-anchor">#</a> 1.1.2 立即执行函数表达式（IIFE）</h3> <p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表 达式，第二个 ( ) 执行了这个函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。把window当作参数传递进去，可以实现两个IIFE表达式互相访问了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span> <span class="token parameter">global</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3 </span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> global<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span> window <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><h2 id="_2-1-块作用域"><a href="#_2-1-块作用域" class="header-anchor">#</a> 2.1  块作用域</h2> <blockquote><p>至少从 ES3 发布以来，JavaScript 中就有了块作用域，而 with 和 catch 分句就是块作用域的两个小例子。但随着 ES6 中引入了 let，我们的代码终于有了创建完整、不受约束的块作用域的能力，块作用域在功能上和代码风格上都拥有很多激动人心的新特性。除JavaScript外的很多编程语言都支持块作用域，我们在for循环的头部直接定义了变量i，通常是因为只想在for循环内部的上下文中使用i，而忽略了i会被绑定在外部作用域(函数或全局)中的事实。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为什么要把一个只在 for 循环内部使用(至少是应该只在内部使用)的变量 i 污染到整个
函数作用域中呢？变量 i 的块作用域(如果存在的话)将使得其只能在 for 循环内部使用，如果在函数中其他地方使用会导致错误。这对保证变量不会被混乱地复用及提升代码的可维护性都有很大帮助。这就是块作用域的用处，变量的声明应该距离使用的地方越近越好，并最大限度地本地化。另外一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> bar <span class="token operator">=</span> foo <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  bar <span class="token operator">=</span> <span class="token function">something</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。</p> <h3 id="_2-1-1-with"><a href="#_2-1-1-with" class="header-anchor">#</a> 2.1.1  with</h3> <p>它是块作用域的一 个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外 部作用域中有效。</p> <h3 id="_2-1-2-try-catch"><a href="#_2-1-2-try-catch" class="header-anchor">#</a> 2.1.2  try/catch</h3> <p>非常少有人会注意到 JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作
用域，其中声明的变量仅在 catch 内部有效。
例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">undefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行一个非法操作来强制制造一个异常</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 能够正常执行! </span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError: err not found</span>
</code></pre></div><h3 id="_2-1-3-let"><a href="#_2-1-3-let" class="header-anchor">#</a> 2.1.3  let</h3> <p>let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。换句话说，let为其声明的变量隐式地了所在的块作用域。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> bar <span class="token operator">=</span> foo <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  bar <span class="token operator">=</span> <span class="token function">something</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre></div><p>只要声明是有效的，在声明中的任意位置都可以使用<code>{ .. }</code>括号来为 let 创建一个用于绑 定的块。但是使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不
“存在”。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">// ReferenceError bar is not defined</span>
  <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>垃圾收集，另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。</li> <li>let循环，一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre></div><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环 的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。
下面通过另一种方式来说明每次迭代时进行重新绑定的行为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token keyword">let</span> j<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 每个迭代重新绑定！</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-1-4-const"><a href="#_2-1-4-const" class="header-anchor">#</a> 2.1.4  const</h3> <p>除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的 (常量)。const 声明一个只读的常量。一旦声明，常量的值就不会改变。这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p> <ul><li>const命令跟let命令一样不存在变量提升、具有块级作用域、存在暂时性死区。</li> <li>const 命令实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
<span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cannot access 'foo' before initializatio</span>
  <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  foo<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'james9527'</span><span class="token punctuation">;</span>
  foo<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//james9527</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//18</span>
  foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//TypeError: Assignment to constant variable.</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-1-5-块作用域的替代方案"><a href="#_2-1-5-块作用域的替代方案" class="header-anchor">#</a> 2.1.5  块作用域的替代方案</h3> <p>在从 ES6 之前的环境向 ES6 过渡时，使用代码转换工具来对 ES6 代码进行处理，生成兼容 ES5 的代码。</p> <ul><li>Traceur
Google 维护着一个名为 Traceur 的项目，该项目正是用来将 ES6 代码转换成兼容 ES6 之前 的环境(大部分是 ES5，但不是全部)。TC39 委员会依赖这个工具(也有其他工具)来测 试他们指定的语义化相关的功能。Traceur 会将我们的代码片段转换成什么样子？你能猜到的~</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
 <span class="token keyword">try</span> <span class="token punctuation">{</span>
   <span class="token keyword">throw</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过使用这样的工具，我们就可以在使用块作用域时无需考虑目标平台是否是 ES6 环境， 因为 try/catch 从 ES3 开始就存在了(并且一直是这样工作的)。</p> <ul><li>隐式和显式作用域（let作用域或let声明）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// ReferenceError</span>
</code></pre></div><h2 id="_3-1-小结"><a href="#_3-1-小结" class="header-anchor">#</a> 3.1  小结</h2> <ul><li>函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会
在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，
也可以属于某个代码块(通常指<code>{ .. }</code>内部)。</li> <li>从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。</li> <li>在 ES6 中引入了 let 关键字(var 关键字的表亲)，用来在任意代码块中声明变量。if (..) { let a = 2; } 会声明一个劫持了 if 的<code>{ .. }</code>块的变量，并且将变量添加到这个块 中。</li> <li>IIFE 和 try/catch 并不是完全等价的，因为如果将一段代码中的任意一部分拿出来 用函数进行包裹，会改变这段代码的含义，其中的 this、return、break 和 contine 都会 发生变化。IIFE 并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。最后问题就变成了：你是否想要块作用域？如果你想要，这些工具就可以帮助你。如果不想要，继续使用var来写代码就好了！</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c069b616.js" defer></script><script src="/assets/js/2.9f793532.js" defer></script><script src="/assets/js/20.0d118671.js" defer></script>
  </body>
</html>
